(define (expmod base exp m)
	(define (non-trivial-check-squaremod x squaremod)
		(if (and (= squaremod 1) (not (or (= x 1) (= x (- m 1))))) 0 squaremod))
	(define (non-trivial-check x)
		(non-trivial-check-squaremod x (remainder (square x) m)))
	(cond ((= exp 0) 1)
			((even? exp)				
				(non-trivial-check (expmod base (/ exp 2) m)))
			(else
				(remainder
					(* base (expmod base (- exp 1) m))
					m))))
(define (miller-rabin-test n)
	(define (try-it a)
		(= (expmod a (- n 1) n) 1))
	(try-it (+ 1 (random (- n 1)))))
(define (fast-prime? n times)
	(cond ((= times 0) true)
			((miller-rabin-test n) (fast-prime? n (- times 1)))
			(else false)))
(define (prime? n)
	(define (iter-miller-rabin-test a)
		(cond ((= a 0) true)
				((= (expmod a (- n 1) n) 1) (iter-miller-rabin-test (- a 1)))
				(else false)))
	(iter-miller-rabin-test (- n 1)))
(define (gcd a b)
	(if (= b 0)
		a
		(gcd b (remainder a b))))
(define (sum-combiner x y)
	(+ x y))
(define (product-combiner x y)
	(* x y))
(define (identity x) x)
(define (inc x) (+ x 1))
(define (filtered-accumulate filter combiner null-value term a next b)
	(cond ((> a b) null-value)
		((filter a) (combiner (term a) (filtered-accumulate filter combiner null-value term (next a) next b)))
		(combiner null-value (filtered-accumulate filter combiner null-value term (next a) next b))))
(define (prime-sum a b)
	(filtered-accumulate prime? sum-combiner 0 identity a inc b))
(define (gcd-product n)
	(define (gcd-n? x)
		(= 1 (gcd n x)))
	(filtered-accumulate gcd-n? product-combiner 1 identity 1 inc n))